{"version":3,"sources":["../src/index.ts","../src/auto-text-size-standalone.ts","../src/auto-text-size-react.tsx"],"sourcesContent":["export { autoTextSize, updateTextSize } from \"./auto-text-size-standalone.js\";\nexport { AutoTextSize } from \"./auto-text-size-react.js\";\n","/**\n * Ensures that `func` is not called more than once per animation frame.\n *\n * Using requestAnimationFrame in this way ensures that we render as often as\n * possible without excessively blocking the UI.\n */\nfunction throttleAnimationFrame(func: () => void): () => void {\n  let wait = false;\n\n  return () => {\n    if (!wait) {\n      wait = true;\n      requestAnimationFrame(() => {\n        func();\n        wait = false;\n      });\n    }\n  };\n}\n\ntype AlgoOpts = {\n  innerEl: HTMLElement;\n  containerEl: HTMLElement;\n  fontSizePx: number;\n  minFontSizePx: number;\n  maxFontSizePx: number;\n  fontSizePrecisionPx: number;\n  updateFontSizePx: (px: number) => number;\n};\n\n/**\n * Ensure no overflow. Underflow is preferred since it doesn't look visually\n * broken like overflow does.\n *\n * Some browsers (eg. Safari) are not good with sub-pixel font sizing, making it so\n * that visual overflow can occur unless we adjust for it.\n */\nconst antiOverflowAlgo = ({\n  fontSizePx,\n  minFontSizePx,\n  fontSizePrecisionPx,\n  updateFontSizePx,\n  breakPredicate: breakPred,\n}: Pick<\n  AlgoOpts,\n  \"fontSizePx\" | \"minFontSizePx\" | \"fontSizePrecisionPx\" | \"updateFontSizePx\"\n> & { breakPredicate: () => boolean }): void => {\n  const maxIterCount = Math.ceil(1 / fontSizePrecisionPx); // 1 px should always be enough.\n  let iterCount = 0;\n\n  while (fontSizePx > minFontSizePx && iterCount < maxIterCount) {\n    if (breakPred()) break;\n    fontSizePx = updateFontSizePx(fontSizePx - fontSizePrecisionPx);\n    iterCount++;\n  }\n};\n\nconst getContentWidth = (element: HTMLElement): number => {\n  const computedStyle = getComputedStyle(element);\n  return (\n    element.clientWidth -\n    parseFloat(computedStyle.paddingLeft) -\n    parseFloat(computedStyle.paddingRight)\n  );\n};\n\nconst getContentHeight = (element: HTMLElement): number => {\n  const computedStyle = getComputedStyle(element);\n  return (\n    element.clientHeight -\n    parseFloat(computedStyle.paddingTop) -\n    parseFloat(computedStyle.paddingBottom)\n  );\n};\n\nconst multilineAlgo = (opts: AlgoOpts): void => {\n  opts.innerEl.style.whiteSpace = \"nowrap\";\n\n  onelineAlgo(opts);\n\n  if (opts.innerEl.scrollWidth > getContentWidth(opts.containerEl)) {\n    opts.innerEl.style.whiteSpace = \"normal\";\n  }\n};\n\nconst onelineAlgo = ({\n  innerEl,\n  containerEl,\n  fontSizePx,\n  minFontSizePx,\n  maxFontSizePx,\n  fontSizePrecisionPx,\n  updateFontSizePx,\n}: AlgoOpts): void => {\n  const maxIterCount = 10; // Safety fallback to avoid infinite loop\n  let iterCount = 0;\n  let prevOverflowFactor = 1;\n\n  while (iterCount < maxIterCount) {\n    const w0 = innerEl.scrollWidth;\n    const w1 = getContentWidth(containerEl);\n\n    const canGrow = fontSizePx < maxFontSizePx && w0 < w1;\n    const canShrink = fontSizePx > minFontSizePx && w0 > w1;\n\n    const overflowFactor = w0 / w1;\n\n    // The browser cannot render a difference based on the previous font size update\n    if (prevOverflowFactor === overflowFactor) {\n      break;\n    }\n\n    if (!(canGrow || canShrink)) {\n      break;\n    }\n\n    const updatePx = fontSizePx / overflowFactor - fontSizePx;\n    const prevFontSizePx = fontSizePx;\n    fontSizePx = updateFontSizePx(fontSizePx + updatePx);\n\n    // Stop iterating when converging\n    if (Math.abs(fontSizePx - prevFontSizePx) <= fontSizePrecisionPx) {\n      break;\n    }\n\n    prevOverflowFactor = overflowFactor;\n    iterCount++;\n  }\n\n  antiOverflowAlgo({\n    fontSizePx,\n    minFontSizePx,\n    updateFontSizePx,\n    fontSizePrecisionPx,\n    breakPredicate: () => innerEl.scrollWidth <= getContentWidth(containerEl),\n  });\n};\n\n/**\n * Binary search for the best font size in the range [minFontSizePx, maxFontSizePx].\n */\nconst boxAlgo = ({\n  innerEl,\n  containerEl,\n  fontSizePx,\n  minFontSizePx,\n  maxFontSizePx,\n  fontSizePrecisionPx,\n  updateFontSizePx,\n}: AlgoOpts) => {\n  const maxIterCount = 100; // Safety fallback to avoid infinite loop\n\n  // Start the binary search in the middle.\n  fontSizePx = updateFontSizePx((maxFontSizePx - minFontSizePx) * 0.5);\n\n  // Each subsequent update will halve the search space.\n  let updatePx = (maxFontSizePx - minFontSizePx) * 0.25;\n  let iterCount = 0;\n\n  while (updatePx > fontSizePrecisionPx && iterCount < maxIterCount) {\n    const w0 = innerEl.scrollWidth;\n    const w1 = getContentWidth(containerEl);\n\n    const h0 = innerEl.scrollHeight;\n    const h1 = getContentHeight(containerEl);\n\n    if (w0 === w1 && h0 === h1) break;\n\n    /**\n     * Use `<=` rather than `<` since equality is possible even though there is\n     * room for resizing in the other dimension.\n     */\n    if (fontSizePx < maxFontSizePx && w0 <= w1 && h0 <= h1) {\n      fontSizePx = updateFontSizePx(fontSizePx + updatePx);\n    } else if (fontSizePx > minFontSizePx && (w0 > w1 || h0 > h1)) {\n      fontSizePx = updateFontSizePx(fontSizePx - updatePx);\n    }\n\n    updatePx *= 0.5; // Binary search. Don't change this number.\n    iterCount++;\n  }\n\n  antiOverflowAlgo({\n    fontSizePx,\n    minFontSizePx,\n    updateFontSizePx,\n    fontSizePrecisionPx,\n    breakPredicate: () =>\n      innerEl.scrollWidth <= getContentWidth(containerEl) &&\n      innerEl.scrollHeight <= getContentHeight(containerEl),\n  });\n};\n\nexport type Options = {\n  mode?: \"oneline\" | \"multiline\" | \"box\" | \"boxoneline\" | undefined;\n  minFontSizePx?: number | undefined;\n  maxFontSizePx?: number | undefined;\n  fontSizePrecisionPx?: number | undefined;\n};\n\n/**\n * Make text fit container, prevent overflow and underflow.\n *\n * Adjusts the font size of `innerEl` so that it precisely fills `containerEl`.\n */\nexport function updateTextSize({\n  innerEl,\n  containerEl,\n  mode = \"multiline\",\n  minFontSizePx = 8,\n  maxFontSizePx = 160,\n  fontSizePrecisionPx = 0.1,\n}: Options & {\n  innerEl: HTMLElement;\n  containerEl: HTMLElement;\n}): void {\n  const t0 = performance.now();\n\n  if (!isFinite(minFontSizePx)) {\n    throw new Error(`Invalid minFontSizePx (${minFontSizePx})`);\n  }\n\n  if (!isFinite(minFontSizePx)) {\n    throw new Error(`Invalid maxFontSizePx (${maxFontSizePx})`);\n  }\n\n  if (!isFinite(fontSizePrecisionPx) || fontSizePrecisionPx === 0) {\n    throw new Error(`Invalid fontSizePrecisionPx (${fontSizePrecisionPx})`);\n  }\n\n  if (containerEl.children.length > 1) {\n    console.warn(\n      `AutoTextSize has ${\n        containerEl.children.length - 1\n      } siblings. This may interfere with the algorithm.`\n    );\n  }\n\n  const containerStyles: Partial<CSSStyleDeclaration> = {\n    // Necessary to correctly compute the dimensions `innerEl`.\n    display: \"flex\",\n    alignItems: \"start\",\n  };\n\n  const innerStyles: Partial<CSSStyleDeclaration> = {\n    display: \"block\", // Necessary to compute dimensions.\n  };\n\n  if (mode === \"oneline\") {\n    innerStyles.whiteSpace = \"nowrap\";\n  } else if (mode === \"multiline\") {\n    innerStyles.wordBreak = \"break-word\";\n    // white-space is controlled dynamically in multiline mode\n  } else if (mode === \"box\") {\n    innerStyles.whiteSpace = \"pre-wrap\";\n    innerStyles.wordBreak = \"break-word\";\n  } else if (mode === \"boxoneline\") {\n    innerStyles.whiteSpace = \"nowrap\";\n  }\n\n  Object.assign(containerEl.style, containerStyles);\n  Object.assign(innerEl.style, innerStyles);\n\n  const fontSizeStr = window\n    .getComputedStyle(innerEl, null)\n    .getPropertyValue(\"font-size\");\n  let fontSizePx = parseFloat(fontSizeStr);\n  let iterations = 0;\n\n  const updateFontSizePx = (px: number): number => {\n    px = Math.min(Math.max(px, minFontSizePx), maxFontSizePx);\n    // console.debug(\n    //   `setFontSizePx ${px > fontSizePx ? \"up\" : \"down\"} (abs: ${\n    //     px / fontSizePx\n    //   }, rel: ${(px - fontSizePx) / fontSizePx}) ${px}`\n    // );\n    fontSizePx = px;\n    innerEl.style.fontSize = `${fontSizePx}px`;\n    iterations++;\n    return fontSizePx;\n  };\n\n  if (fontSizePx > maxFontSizePx || fontSizePx < minFontSizePx) {\n    updateFontSizePx(fontSizePx);\n  }\n\n  const algoOpts = {\n    innerEl,\n    containerEl,\n    fontSizePx,\n    minFontSizePx,\n    maxFontSizePx,\n    fontSizePrecisionPx,\n    updateFontSizePx,\n  };\n\n  if (mode === \"oneline\") {\n    onelineAlgo(algoOpts);\n  } else if (mode === \"multiline\") {\n    multilineAlgo(algoOpts);\n  } else if (mode === \"box\") {\n    boxAlgo(algoOpts);\n  } else if (mode === \"boxoneline\") {\n    boxAlgo(algoOpts);\n  }\n}\n\ntype DisconnectableFunction = {\n  (): void;\n  disconnect: () => void;\n};\n\n/**\n * Make text fit container, prevent overflow and underflow.\n *\n * Adjusts the font size of `innerEl` so that it precisely fills `containerEl`.\n *\n * Throttles all invocations to next animation frame (through\n * `requestAnimationFrame`).\n *\n * Sets up a `ResizeObserver` to automatically run `autoTextSize` when\n * `containerEl` resizes. Call `disconnect()` when done to disconnect the resize\n * observer to prevent memory leaks.\n */\nexport function autoTextSize({\n  innerEl,\n  containerEl,\n  mode,\n  minFontSizePx,\n  maxFontSizePx,\n  fontSizePrecisionPx,\n}: Options & {\n  innerEl: HTMLElement;\n  containerEl: HTMLElement;\n}): DisconnectableFunction {\n  // Initialize as `undefined` to always run directly when instantiating.\n  let containerDimensions: [number, number] | undefined = undefined;\n\n  // Use type `any` so that we can add the `.disconnect` property later on.\n  const throttledUpdateTextSize: any = throttleAnimationFrame(() => {\n    updateTextSize({\n      innerEl,\n      containerEl,\n      mode,\n      maxFontSizePx,\n      minFontSizePx,\n      fontSizePrecisionPx,\n    });\n\n    containerDimensions = [\n      getContentWidth(containerEl),\n      getContentHeight(containerEl),\n    ];\n  });\n\n  const resizeObserver = new ResizeObserver(() => {\n    const prevContainerDimensions = containerDimensions;\n    containerDimensions = [\n      getContentWidth(containerEl),\n      getContentHeight(containerEl),\n    ];\n\n    if (\n      prevContainerDimensions?.[0] !== containerDimensions[0] ||\n      prevContainerDimensions?.[1] !== containerDimensions[1]\n    ) {\n      throttledUpdateTextSize();\n    }\n  });\n\n  // It calls the callback directly.\n  resizeObserver.observe(containerEl);\n\n  // The native code `resizeObserver.disconnect` needs the correct context.\n  // Retain the context by wrapping in arrow function. Read more about this:\n  // https://stackoverflow.com/a/9678166/19306180\n  throttledUpdateTextSize.disconnect = () => resizeObserver.disconnect();\n\n  return throttledUpdateTextSize;\n}\n","import React, {\n  DetailedHTMLProps,\n  HTMLAttributes,\n  ReactElement,\n  ReactHTML,\n  useCallback,\n  useEffect,\n  useRef,\n} from \"react\";\nimport { autoTextSize, Options } from \"./auto-text-size-standalone.js\";\n\n/**\n * Make text fit container, prevent overflow and underflow.\n */\nexport function AutoTextSize({\n  mode,\n  minFontSizePx,\n  maxFontSizePx,\n  fontSizePrecisionPx,\n  as: Comp = \"div\", // TODO: The `...rest` props are not typed to reflect another `as`.\n  children,\n  ...rest\n}: Options & {\n  as?: keyof ReactHTML | React.ComponentType<any>;\n} & DetailedHTMLProps<\n    HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  >): ReactElement {\n  const updateTextSizeRef = useRef<ReturnType<typeof autoTextSize>>();\n\n  useEffect(() => updateTextSizeRef.current?.(), [children]);\n\n  const refCallback = useCallback(\n    (innerEl: HTMLElement | null) => {\n      updateTextSizeRef.current?.disconnect();\n\n      const containerEl = innerEl?.parentElement;\n      if (!innerEl || !containerEl) return;\n\n      updateTextSizeRef.current = autoTextSize({\n        innerEl,\n        containerEl,\n        mode,\n        minFontSizePx,\n        maxFontSizePx,\n        fontSizePrecisionPx,\n      });\n    },\n    [mode, minFontSizePx, maxFontSizePx, fontSizePrecisionPx]\n  );\n\n  return (\n    <Comp ref={refCallback} {...rest}>\n      {children}\n    </Comp>\n  );\n}\n"],"mappings":"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","names":["_a","React"]}